<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Body position tracking | xrazis · Haris Razis</title>
<meta name=keywords content="Web,Frontend,Backend,Networking,System"><meta name=description content="Scalable IoT solution for real-time body position tracking"><meta name=author content><link rel=canonical href=https://haris.razis.com/posts/ichnaea/><link crossorigin=anonymous href=/assets/css/stylesheet.ccf060867b011799d80620374a4f5e1b49a687a7ab60d9f5beb3f41595781b01.css integrity="sha256-zPBghnsBF5nYBiA3Sk9eG0mmh6erYNn1vrP0FZV4GwE=" rel="preload stylesheet" as=style><link rel=icon href=https://haris.razis.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://haris.razis.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://haris.razis.com/favicon.png><link rel=apple-touch-icon href=https://haris.razis.com/apple-touch-icon.png><link rel=mask-icon href=https://haris.razis.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://haris.razis.com/posts/ichnaea/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Body position tracking"><meta property="og:description" content="Scalable IoT solution for real-time body position tracking"><meta property="og:type" content="article"><meta property="og:url" content="https://haris.razis.com/posts/ichnaea/"><meta property="og:image" content="https://haris.razis.com/favicon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-26T00:00:00+00:00"><meta property="og:site_name" content="xrazis"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://haris.razis.com/favicon.png"><meta name=twitter:title content="Body position tracking"><meta name=twitter:description content="Scalable IoT solution for real-time body position tracking"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://haris.razis.com/posts/"},{"@type":"ListItem","position":2,"name":"Body position tracking","item":"https://haris.razis.com/posts/ichnaea/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Body position tracking","name":"Body position tracking","description":"Scalable IoT solution for real-time body position tracking","keywords":["Web","Frontend","Backend","Networking","System"],"articleBody":"Introduction A while ago I submitted my thesis with its subject being the study of the architecture of BAN and PAN, and their applications, with the aim of optimizing athletes performance, by enhancing personalized training practices. I was also tasked with creating an e-sport application that would collect and analyze data on the athlete’s body position in real-time. I named the e-sport application Icnhaea, and I will be referring to it as so for the rest of this post.\nDeveloping Ichnaea proved a challenge for me, as it tested my knowledge and understanding of full-stack applications. I wanted to build a resilient, multi-tenant application with scaling capabilities that would not just tick the boxes for a thesis but be a worthwhile project that would make me a better engineer.\nThis post will be a rough overview of the thesis. You can find the source and doc here.\nArchitecture To begin with, deployment is handled by docker and docker-compose. Abstracting the configuration to a handy yaml file, while keeping the development environment the same across machines makes deployment a breeze. Running the project will create the following services:\nClient, a Node.js app that collects and sends the data to the backend. Backend, a Node.js server that is responsible for data and user storage, client and SPA socket connection, and exposing an API. Three Databases, each for its distinct purpose: Influxdb, used to store the bulk of data produced from the client devices. A Grafana instance, attached to Influx. Redis, used for publish-subscribe. MongoDB, used as the user store. Frontend, a SPA built on Vue with Typescript. As you can see, I decided to go full-on with JavaScript and TypeScript for Ichnaea, as I was already familiar with lots of libraries and frameworks in the respective ecosystems.\nClient The client device is an Arduino with an IMU sensor. The program can either run on the host machine or on a Raspberry Pi that acts like a getaway for the Arduino. The client does some basic calculations with the help of Johnny-five, then the data is then streamed to the server, and subsequently to the frontend. The frontend does the final calculations that are needed for the model visualization. This way we avoid making any ‘heavy’ computations on the client device, thus allowing for small and power efficient getaways like a Pi Zero with multiple micro-controllers attached on it.\nWhat is an IMU and how do you make sense of its readings? An Inertial Measurement Unit can be found pretty much everywhere today and is a combination of accelerometers, gyroscopes, and magnetometers. They are used in navigation systems, smartphones, fitness trackers, and many more. Classified by Degrees Of Freedom, an IMU of 9-DOF will feature 3 degrees each of acceleration, magnetic orientation, and angular velocity. As a rule of thumb the higher the DOF rating the more accurate an IMU will be.\nTo get some meaningful readings from an IMU a filter has to be used. There are many implementations from the notoriously hard Kalman filter to the relatively newly founded Madgwick filter. I decided to go with the complementary filter, an easy-to-understand and even easier to implement a filter. With the complementary filter we are keeping the best attributes from each sensor, using the gyro for short-term calculations and the accelerometer for long-term calculations. Why is that?\nThe accelerometer picks up even the smallest forces that are working on the object. If you observe the raw output of an accelerometer you will notice that even the tiniest disturbance is measured. Because the accelerometer will not drift we are going to use a low-pass filter on it.\nGyros on the other hand are not susceptible to external forces and can accurately measure angular velocity. Unfortunately, gyroscopes have a tenancy to drift, making them less accurate over time. For this reason, we are going to use a high-pass filter.\nangle = a * (angle + gyroscopeData * dt) + (1 - a) * accelerometerData Variable a ranges from 95 to 98 percent. You should experiment a bit and choose a suitable percentage for your application. This filter is also very easy on resources, so it’s a true fit for low-powered gateways. The client application was designed with extensibility in mind, meaning you can define a new file under the actions directory to handle another type of sensor.\nfunction parseData(imu) { const {temperature, accelerometer, gyro} = imu; // Get pitch, roll, yaw from gyro pitch += (gyro.rate.x / gyroSens) * samplingInterval; roll -= (gyro.rate.y / gyroSens) * samplingInterval; yaw += (gyro.rate.z / gyroSens) * samplingInterval; // Only use accelerometer when forces are ~1g if (accelerometer.acceleration \u003e -1 \u0026\u0026 accelerometer.acceleration \u003c 2) { pitch = 0.98 * pitch + 0.02 * accelerometer.pitch; roll = 0.98 * roll + 0.02 * accelerometer.roll; } // Filter out noise (a small tremor appears with too many fraction digits) pitch = toFixed(pitch); roll = toFixed(roll); yaw = toFixed(yaw); return { pointName: 'IMU', uuid: id, temperature: temperature.celsius, pitch, roll, yaw, acceleration: imu.accelerometer.acceleration, inclination: imu.accelerometer.inclination, orientation: imu.accelerometer.orientation, } } I’ve set the sampling frequency to 10HZ, just enough to get frequent updates on the body position without bogging down the gateway. Things are pretty straightforward from this point on. The client establishes a socket connection with the backend and synchronously transfers data.\nThere is one got ya here. I am using a 6-DOF IMU and that means there is no reference point for the z-axis. Since I am relying completely on the gyro for the yaw angle, a drift is introduced over time. The orange line in the following chart depicts the slow but constant drift of the yaw angle. Here is where a magnetometer would come in handy.\nThere is a lot more going on here. Check out Euler angles (pitch, roll, yaw), accelerometers, gyroscopes, magnetometers.\nBackend The server for Ichnaea was built on Node.js while making use of many popular packages like celebrate for input validation. Express was used for the creation of the API. A route definition is as simple as stating the HTTP action with the desired endpoint and then handling the request accordingly. I am not going to dive into route implementation details. You can find more in the Express documentation.\nIchnaea was built with consideration for multiple tenants and isolation features. It wouldn’t be very smart to stream an athlete’s data to a trainer but his own. Besides offering session capabilities with distinct trainer accounts, an adoption concept has been introduced to solve this exact problem. An athlete in the orphan state has no trainer and is open to be adopted. You can then adopt him by entering the unique id (generated in the output of the client device) to the respective field in the frontend. After adopting the client, the data generated is only streamed to the intended recipient.\nmodule.exports = (server) =\u003e { const io = socket(server); io.adapter(redisAdapter({host: 'redis', port: 6379})); io.on('connection', socket =\u003e { let client; console.log(`Client with id: ${socket.id} just connected with ${socket.conn.transport.name}!`); socket.on('disconnect', () =\u003e console.log('Client disconnected!')); socket.conn.on('upgrade', () =\u003e console.log(`Client with id: ${socket.id} upgraded to ${socket.conn.transport.name}!`)); socket.on('subscribe', async room =\u003e { const {subscribe, id} = JSON.parse(room); const socketID = socket.id.toString(); socket.join(room); console.log(`Client with id: ${socket.id} joined room \"${subscribe}\"`); try { if (subscribe === 'clients') { client = await Athlete.findOne({id}).populate('_trainer'); sub.on('message', async (channel, msg) =\u003e { if (String(client?._trainer?._id) === JSON.parse(msg)) client._trainer = await User.findOne({_id: client._trainer}); }); sub.subscribe('updateSocketID'); if (client) { await Athlete.findOneAndUpdate({id}, {socketID}); return; } await saveAthlete(id, socketID); } else if (subscribe === 'dashboard') { client = await User.findOne({id}); pub.publish('updateSocketID', JSON.stringify(client._id)); await User.findOneAndUpdate({id}, {socketID}); } } catch (e) { console.log(e); } }); socket.on('data', async data =\u003e { if (client?._trainer) { iWrite(data); io.volatile.to(client._trainer.socketID).emit('console', data); } }); }); } The aforementioned behavior is demonstrated in the code snippet above. One nasty bug that bothered me for a couple of days was the client device sending data to an old socket id if the dashboard (frontend application) established a socket connection after the client or if the trainer refreshed the page. That happened because the socket id of the dashboard was now outdated since a new socket connection was established and a new id was generated. In addition to code being block scoped in a socket.io event that made it impossible to solve with the libraries built-in functions. Hitting the database at preset intervals was a big no. Imagine having tens of clients doing the same thing. That quickly brings the requests to thousands per minute.\nRedis pub-sub came to the rescue! By subscribing to the updateSocketID event whenever a client connects and triggering it when a dashboard (re)connects, excess database reads are avoided. The only thing the subscriber does on that event trigger is check if his trainer changed id and pick up the new one from the store if so.\nThe rest of the server is pretty basic. Field validation with celebrate, session and user management with bcrypt/passport/cookie-session, cors and rate limiter for security reasons, and the list goes on. Check the repo for more details.\nDatabases Ichnaea utilizes three databases, each for its distinct purpose.\nMongoDB MongoDB was chosen for the user store. Two models were created, one for the user logging to the dashboard and one to represent each distinct athlete. Each model has some basic identification features and the all-important socketID. This field stores the last socket connection id, useful to stream data only to the intended recipient.\nAnother important field is the _trainer, found only in the athletes model. With that we keep a reference to the trainer of the athlete, that is the user _id. To retrieve the trainer details at the same time as the athlete’s details, we can use the .populate() function like so.\nclient = await Athlete.findOne({id}).populate('_trainer'); InfluxDB A time-series database was a precise fit for the serial data generated from the sensors. Writing data to influx is as easy as defining a new Point with the data you want to save. InfluxDB comes with a rich dashboard with various data display capabilities. A Grafana instance is attached to the Influx instance, so you can squeeze out every metric from Ichnaea.\nconst imuPoint = new Point(pointName) .tag('client', uuid) .tag('sensor', 'IMU') .floatField('temperature', temperature) .floatField('pitch', pitch) .floatField('roll', roll) .floatField('yaw', yaw) .floatField('acceleration', acceleration) .floatField('inclination', inclination) .floatField('orientation', orientation); writeApi.writePoint(imuPoint); Redis Redis is used as a publish-subscribe mechanism in two places. The first place we make use of pubsub is updating the socket id dynamically when the dashboard reconnects, as mentioned a couple of sections before. Secondly, it is used as a socket.io adapter, helping when scaling up with multiple instances of the backend. This way we can broadcast a message to multiple clients even if they are connected to a different server. You can read more about that here.\nFrontend Last but not least, the Frontend is built on Vue.js, and is a single page application that makes the dashboard of Ichnaea. Vue is a lovely framework that is extensible with things like routing and state management. I won’t go into any details about the framework - feel free to browse the docs.\nI tried to make the dashboard as realistic as possible. It has the following features:\nView the latest README from Github right in the app. Make changes to the user and athlete profile. Adopt or drop athletes. View, search, or inspect athletes and their details. View athlete data in a table or model in real-time. Not something overly impressive, but some basic functionality that would form the building blocks of a real-world app.\nThe main point of the dashboard is the model animation. I fixed a Mixamo model to a Three.js scene, and with the help of quaternions, the model animation is a breeze. I used the build in function from Three.js for the conversion from Euler, setFromEuler(). Taking a look inside setFromEuler(), we can see that the conversion is simple enough.\nconst cos = Math.cos; const sin = Math.sin; const c1 = cos(x / 2); const c2 = cos(y / 2); const c3 = cos(z / 2); const s1 = sin(x / 2); const s2 = sin(y / 2); const s3 = sin(z / 2); this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; I also keep a reference of body parts, and set its position as so.\nthis.head = object.getObjectByName('mixamorig1Head'); this.head.quaternion.setFromEuler(new Euler(this.roll, this.yaw, this.pitch)); Demo Placing the micro-controller on top of the head and making three discreet movements from neutral to left, back, and upwards right, maps with precision the physical movement and accurately depicts it on the model while testing all three axes, roll-pitch-yaw.\nLet’s try the same but for another body part, this time the left arm. Starting from a relaxed hanging position we pull the arm upwards making a slow circular motion and then returning to the starting point. This time due to us deliberately making a slow movement, we can now see the drift introduced from the gyroscope in the yaw angle. That skews with all the readings and thus placing the hand in a wrong final position.\nConclusion This was an overview of Ichnaea, what I thought were the most interesting points, and by no means the full picture. What needs to be improved? Abstracting the sensor positioning logic to a UI where the user can drag and drop each sensor to the respective body and not hard-coding it. Making the client device smaller and self-sufficient with a battery and extensive connectivity options. Lastly, some ML with smart alerts and corrections would provide smart insights.\n","wordCount":"2280","inLanguage":"en","image":"https://haris.razis.com/favicon.png","datePublished":"2021-11-26T00:00:00Z","dateModified":"2021-11-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://haris.razis.com/posts/ichnaea/"},"publisher":{"@type":"Organization","name":"xrazis · Haris Razis","logo":{"@type":"ImageObject","url":"https://haris.razis.com/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://haris.razis.com/ accesskey=h title="xrazis (Alt + H)">xrazis</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://haris.razis.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://haris.razis.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://haris.razis.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://haris.razis.com/>Home</a>&nbsp;»&nbsp;<a href=https://haris.razis.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Body position tracking</h1><div class=post-meta><span title='2021-11-26 00:00:00 +0000 UTC'>26 November, 2021</span>&nbsp;·&nbsp;11 min&nbsp;|&nbsp;<a href=https://github.com/xrazis/haris.razis.com/tree/main/content/posts/ichnaea.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#architecture aria-label=Architecture>Architecture</a></li><li><a href=#client aria-label=Client>Client</a><ul><ul><li><a href=#what-is-an-imu-and-how-do-you-make-sense-of-its-readings aria-label="What is an IMU and how do you make sense of its readings?">What is an IMU and how do you make sense of its readings?</a></li></ul></ul></li><li><a href=#backend aria-label=Backend>Backend</a></li><li><a href=#databases aria-label=Databases>Databases</a><ul><ul><li><a href=#mongodb aria-label=MongoDB>MongoDB</a></li><li><a href=#influxdb aria-label=InfluxDB>InfluxDB</a></li><li><a href=#redis aria-label=Redis>Redis</a></li></ul></ul></li><li><a href=#frontend aria-label=Frontend>Frontend</a></li><li><a href=#demo aria-label=Demo>Demo</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>A while ago I submitted my thesis with its subject being the study of the architecture of BAN and PAN, and their
applications, with the aim of optimizing athletes performance, by enhancing personalized training practices. I was also
tasked with creating an e-sport application that would collect and analyze data on the athlete’s body position in
real-time. I named the e-sport application Icnhaea, and I will be referring to it as so for the rest of this post.</p><p>Developing Ichnaea proved a challenge for me, as it tested my knowledge and understanding of full-stack applications. I
wanted to build a resilient, multi-tenant application with scaling capabilities that would not just tick the boxes for a
thesis but be a worthwhile project that would make me a better engineer.</p><p>This post will be a rough overview of the thesis. You can find the source and
doc <a href=https://github.com/xrazis/ichnaea>here</a>.</p><h1 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h1><p>To begin with, deployment is handled by docker and docker-compose. Abstracting the configuration to a handy yaml file,
while keeping the development environment the same across machines makes deployment a breeze. Running the project will
create the following services:</p><ul><li><strong>Client</strong>, a Node.js app that collects and sends the data to the backend.</li><li><strong>Backend</strong>, a Node.js server that is responsible for data and user storage, client and SPA socket connection, and
exposing an API.</li><li>Three Databases, each for its distinct purpose:<ul><li><strong>Influxdb</strong>, used to store the bulk of data produced from the client devices.<ul><li>A <strong>Grafana</strong> instance, attached to Influx.</li></ul></li><li><strong>Redis</strong>, used for publish-subscribe.</li><li><strong>MongoDB</strong>, used as the user store.</li></ul></li><li><strong>Frontend</strong>, a SPA built on Vue with Typescript.</li></ul><p><img loading=lazy src=/blog/ichnaea/thesis.drawio.png#center alt=thesis.drawio.png></p><p>As you can see, I decided to go full-on with JavaScript and TypeScript for Ichnaea, as I was already familiar with lots
of libraries and frameworks in the respective ecosystems.</p><h1 id=client>Client<a hidden class=anchor aria-hidden=true href=#client>#</a></h1><p>The client device is an Arduino with an IMU sensor. The program can either run on the host machine or on a Raspberry Pi
that acts like a getaway for the Arduino. The client does some basic calculations with the help of Johnny-five, then the
data is then streamed to the server, and subsequently to the frontend. The frontend does the final calculations that are
needed for the model visualization. This way we avoid making any &lsquo;heavy&rsquo; computations on the client device, thus
allowing for small and power efficient getaways like a Pi Zero with multiple micro-controllers attached on it.</p><h3 id=what-is-an-imu-and-how-do-you-make-sense-of-its-readings>What is an IMU and how do you make sense of its readings?<a hidden class=anchor aria-hidden=true href=#what-is-an-imu-and-how-do-you-make-sense-of-its-readings>#</a></h3><p>An Inertial Measurement Unit can be found pretty much everywhere today and is a combination of accelerometers,
gyroscopes, and magnetometers. They are used in navigation systems, smartphones, fitness trackers, and many more.
Classified by Degrees Of Freedom, an IMU of 9-DOF will feature 3 degrees each of acceleration, magnetic orientation, and
angular velocity. As a rule of thumb the higher the DOF rating the more accurate an IMU will be.</p><p>To get some meaningful readings from an IMU a filter has to be used. There are many implementations from the notoriously
hard Kalman filter to the relatively newly founded Madgwick filter. I decided to go with the complementary filter, an
easy-to-understand and even easier to implement a filter. With the complementary filter we are keeping the best
attributes from each sensor, using the gyro for short-term calculations and the accelerometer for long-term
calculations. Why is that?</p><p>The accelerometer picks up even the smallest forces that are working on the object. If you observe the raw output of an
accelerometer you will notice that even the tiniest disturbance is measured. Because the accelerometer will not drift we
are going to use a low-pass filter on it.</p><p>Gyros on the other hand are not susceptible to external forces and can accurately measure angular velocity.
Unfortunately, gyroscopes have a tenancy to drift, making them less accurate over time. For this reason, we are going to
use a high-pass filter.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>angle = a * (angle + gyroscopeData * dt) + (1 - a) * accelerometerData
</span></span></code></pre></div><p>Variable a ranges from 95 to 98 percent. You should experiment a bit and choose a suitable percentage for your
application. This filter is also very easy on resources, so it&rsquo;s a true fit for low-powered gateways. The client
application was designed with extensibility in mind, meaning you can define a new file under the actions directory to
handle another type of sensor.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff7b72>function</span> parseData(imu) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>const</span> {temperature, accelerometer, gyro} <span style=color:#ff7b72;font-weight:700>=</span> imu;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Get pitch, roll, yaw from gyro
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    pitch <span style=color:#ff7b72;font-weight:700>+=</span> (gyro.rate.x <span style=color:#ff7b72;font-weight:700>/</span> gyroSens) <span style=color:#ff7b72;font-weight:700>*</span> samplingInterval;
</span></span><span style=display:flex><span>    roll <span style=color:#ff7b72;font-weight:700>-=</span> (gyro.rate.y <span style=color:#ff7b72;font-weight:700>/</span> gyroSens) <span style=color:#ff7b72;font-weight:700>*</span> samplingInterval;
</span></span><span style=display:flex><span>    yaw <span style=color:#ff7b72;font-weight:700>+=</span> (gyro.rate.z <span style=color:#ff7b72;font-weight:700>/</span> gyroSens) <span style=color:#ff7b72;font-weight:700>*</span> samplingInterval;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Only use accelerometer when forces are ~1g
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>if</span> (accelerometer.acceleration <span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> accelerometer.acceleration <span style=color:#ff7b72;font-weight:700>&lt;</span> <span style=color:#a5d6ff>2</span>) {
</span></span><span style=display:flex><span>        pitch <span style=color:#ff7b72;font-weight:700>=</span>
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>0.98</span> <span style=color:#ff7b72;font-weight:700>*</span> pitch <span style=color:#ff7b72;font-weight:700>+</span>
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>0.02</span> <span style=color:#ff7b72;font-weight:700>*</span> accelerometer.pitch;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        roll <span style=color:#ff7b72;font-weight:700>=</span>
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>0.98</span> <span style=color:#ff7b72;font-weight:700>*</span> roll <span style=color:#ff7b72;font-weight:700>+</span>
</span></span><span style=display:flex><span>            <span style=color:#a5d6ff>0.02</span> <span style=color:#ff7b72;font-weight:700>*</span> accelerometer.roll;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// Filter out noise (a small tremor appears with too many fraction digits)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    pitch <span style=color:#ff7b72;font-weight:700>=</span> toFixed(pitch);
</span></span><span style=display:flex><span>    roll <span style=color:#ff7b72;font-weight:700>=</span> toFixed(roll);
</span></span><span style=display:flex><span>    yaw <span style=color:#ff7b72;font-weight:700>=</span> toFixed(yaw);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> {
</span></span><span style=display:flex><span>        pointName<span style=color:#ff7b72;font-weight:700>:</span> <span style=color:#a5d6ff>&#39;IMU&#39;</span>,
</span></span><span style=display:flex><span>        uuid<span style=color:#ff7b72;font-weight:700>:</span> id,
</span></span><span style=display:flex><span>        temperature<span style=color:#ff7b72;font-weight:700>:</span> temperature.celsius,
</span></span><span style=display:flex><span>        pitch,
</span></span><span style=display:flex><span>        roll,
</span></span><span style=display:flex><span>        yaw,
</span></span><span style=display:flex><span>        acceleration<span style=color:#ff7b72;font-weight:700>:</span> imu.accelerometer.acceleration,
</span></span><span style=display:flex><span>        inclination<span style=color:#ff7b72;font-weight:700>:</span> imu.accelerometer.inclination,
</span></span><span style=display:flex><span>        orientation<span style=color:#ff7b72;font-weight:700>:</span> imu.accelerometer.orientation,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ve set the sampling frequency to 10HZ, just enough to get frequent updates on the body position without bogging down
the gateway. Things are pretty straightforward from this point on. The client establishes a socket connection with the
backend and synchronously transfers data.</p><p>There is one got ya here. I am using a 6-DOF IMU and that means there is no reference point for the z-axis. Since I am
relying completely on the gyro for the yaw angle, a drift is introduced over time. The orange line in the following
chart depicts the slow but constant drift of the yaw angle. Here is where a magnetometer would come in handy.</p><p><img loading=lazy src=/blog/ichnaea/influx-chart.png#center alt=Untitled></p><p>There is a lot more going on here. Check out Euler angles (pitch, roll, yaw), accelerometers, gyroscopes, magnetometers.</p><h1 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h1><p>The server for Ichnaea was built on Node.js while making use of many popular packages like celebrate for input
validation. Express was used for the creation of the API. A route definition is as simple as stating the HTTP action
with the desired endpoint and then handling the request accordingly. I am not going to dive into route implementation
details. You can find more in the Express documentation.</p><p>Ichnaea was built with consideration for multiple tenants and isolation features. It wouldn&rsquo;t be very smart to stream an
athlete&rsquo;s data to a trainer but his own. Besides offering session capabilities with distinct trainer accounts, an
adoption concept has been introduced to solve this exact problem. An athlete in the orphan state has no trainer and is
open to be adopted. You can then adopt him by entering the unique id (generated in the output of the client device) to
the respective field in the frontend. After adopting the client, the data generated is only streamed to the intended
recipient.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>module.exports <span style=color:#ff7b72;font-weight:700>=</span> (server) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>const</span> io <span style=color:#ff7b72;font-weight:700>=</span> socket(server);
</span></span><span style=display:flex><span>    io.adapter(redisAdapter({host<span style=color:#ff7b72;font-weight:700>:</span> <span style=color:#a5d6ff>&#39;redis&#39;</span>, port<span style=color:#ff7b72;font-weight:700>:</span> <span style=color:#a5d6ff>6379</span>}));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    io.on(<span style=color:#a5d6ff>&#39;connection&#39;</span>, socket =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>let</span> client;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        console.log(<span style=color:#a5d6ff>`Client with id: </span><span style=color:#a5d6ff>${</span>socket.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> just connected  with </span><span style=color:#a5d6ff>${</span>socket.conn.transport.name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>!`</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        socket.on(<span style=color:#a5d6ff>&#39;disconnect&#39;</span>, () =&gt; console.log(<span style=color:#a5d6ff>&#39;Client disconnected!&#39;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        socket.conn.on(<span style=color:#a5d6ff>&#39;upgrade&#39;</span>, () =&gt; console.log(<span style=color:#a5d6ff>`Client with id: </span><span style=color:#a5d6ff>${</span>socket.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> upgraded to </span><span style=color:#a5d6ff>${</span>socket.conn.transport.name<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>!`</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        socket.on(<span style=color:#a5d6ff>&#39;subscribe&#39;</span>, <span style=color:#ff7b72>async</span> room =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>const</span> {subscribe, id} <span style=color:#ff7b72;font-weight:700>=</span> JSON.parse(room);
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>const</span> socketID <span style=color:#ff7b72;font-weight:700>=</span> socket.id.toString();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            socket.join(room);
</span></span><span style=display:flex><span>            console.log(<span style=color:#a5d6ff>`Client with id: </span><span style=color:#a5d6ff>${</span>socket.id<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> joined room &#34;</span><span style=color:#a5d6ff>${</span>subscribe<span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>&#34;`</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> (subscribe <span style=color:#ff7b72;font-weight:700>===</span> <span style=color:#a5d6ff>&#39;clients&#39;</span>) {
</span></span><span style=display:flex><span>                    client <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>await</span> Athlete.findOne({id}).populate(<span style=color:#a5d6ff>&#39;_trainer&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    sub.on(<span style=color:#a5d6ff>&#39;message&#39;</span>, <span style=color:#ff7b72>async</span> (channel, msg) =&gt; {
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>if</span> (String(client<span style=color:#ff7b72;font-weight:700>?</span>._trainer<span style=color:#ff7b72;font-weight:700>?</span>._id) <span style=color:#ff7b72;font-weight:700>===</span> JSON.parse(msg))
</span></span><span style=display:flex><span>                            client._trainer <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>await</span> User.findOne({_id<span style=color:#ff7b72;font-weight:700>:</span> client._trainer});
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    sub.subscribe(<span style=color:#a5d6ff>&#39;updateSocketID&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>if</span> (client) {
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>await</span> Athlete.findOneAndUpdate({id}, {socketID});
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>return</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>await</span> saveAthlete(id, socketID);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                } <span style=color:#ff7b72>else</span> <span style=color:#ff7b72>if</span> (subscribe <span style=color:#ff7b72;font-weight:700>===</span> <span style=color:#a5d6ff>&#39;dashboard&#39;</span>) {
</span></span><span style=display:flex><span>                    client <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>await</span> User.findOne({id});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    pub.publish(<span style=color:#a5d6ff>&#39;updateSocketID&#39;</span>, JSON.stringify(client._id));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>await</span> User.findOneAndUpdate({id}, {socketID});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#ff7b72>catch</span> (e) {
</span></span><span style=display:flex><span>                console.log(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        socket.on(<span style=color:#a5d6ff>&#39;data&#39;</span>, <span style=color:#ff7b72>async</span> data =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> (client<span style=color:#ff7b72;font-weight:700>?</span>._trainer) {
</span></span><span style=display:flex><span>                iWrite(data);
</span></span><span style=display:flex><span>                io.<span style=color:#ff7b72>volatile</span>.to(client._trainer.socketID).emit(<span style=color:#a5d6ff>&#39;console&#39;</span>, data);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The aforementioned behavior is demonstrated in the code snippet above. One nasty bug that bothered me for a couple of
days was the client device sending data to an old socket id if the dashboard (frontend application) established a socket
connection after the client or if the trainer refreshed the page. That happened because the socket id of the dashboard
was now outdated since a new socket connection was established and a new id was generated. In addition to code being
block scoped in a socket.io event that made it impossible to solve with the libraries built-in functions. Hitting the
database at preset intervals was a big no. Imagine having tens of clients doing the same thing. That quickly brings the
requests to thousands per minute.</p><p>Redis pub-sub came to the rescue! By subscribing to the updateSocketID event whenever a client connects and triggering
it when a dashboard (re)connects, excess database reads are avoided. The only thing the subscriber does on that event
trigger is check if his trainer changed id and pick up the new one from the store if so.</p><p>The rest of the server is pretty basic. Field validation with celebrate, session and user management with
bcrypt/passport/cookie-session, cors and rate limiter for security reasons, and the list goes on. Check the repo for
more details.</p><h1 id=databases>Databases<a hidden class=anchor aria-hidden=true href=#databases>#</a></h1><p>Ichnaea utilizes three databases, each for its distinct purpose.</p><h3 id=mongodb>MongoDB<a hidden class=anchor aria-hidden=true href=#mongodb>#</a></h3><p>MongoDB was chosen for the user store. Two models were created, one for the user logging to the dashboard and one to
represent each distinct athlete. Each model has some basic identification features and the all-important socketID. This
field stores the last socket connection id, useful to stream data only to the intended recipient.</p><p><img loading=lazy src=/blog/ichnaea/jetbrains-db-diagram.png#center alt=Untitled></p><p>Another important field is the _trainer, found only in the athletes model. With that we keep a reference to the trainer
of the athlete, that is the user _id. To retrieve the trainer details at the same time as the athlete&rsquo;s details, we can
use the .populate() function like so.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>client <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>await</span> Athlete.findOne({id}).populate(<span style=color:#a5d6ff>&#39;_trainer&#39;</span>);
</span></span></code></pre></div><h3 id=influxdb>InfluxDB<a hidden class=anchor aria-hidden=true href=#influxdb>#</a></h3><p>A time-series database was a precise fit for the serial data generated from the sensors. Writing data to influx is as
easy as defining a new Point with the data you want to save. InfluxDB comes with a rich dashboard with various data
display capabilities. A Grafana instance is attached to the Influx instance, so you can squeeze out every metric from
Ichnaea.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff7b72>const</span> imuPoint <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Point(pointName)
</span></span><span style=display:flex><span>    .tag(<span style=color:#a5d6ff>&#39;client&#39;</span>, uuid)
</span></span><span style=display:flex><span>    .tag(<span style=color:#a5d6ff>&#39;sensor&#39;</span>, <span style=color:#a5d6ff>&#39;IMU&#39;</span>)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;temperature&#39;</span>, temperature)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;pitch&#39;</span>, pitch)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;roll&#39;</span>, roll)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;yaw&#39;</span>, yaw)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;acceleration&#39;</span>, acceleration)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;inclination&#39;</span>, inclination)
</span></span><span style=display:flex><span>    .floatField(<span style=color:#a5d6ff>&#39;orientation&#39;</span>, orientation);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>writeApi.writePoint(imuPoint);
</span></span></code></pre></div><h3 id=redis>Redis<a hidden class=anchor aria-hidden=true href=#redis>#</a></h3><p>Redis is used as a publish-subscribe mechanism in two places. The first place we make use of pubsub is updating the
socket id dynamically when the dashboard reconnects, as mentioned a couple of sections before. Secondly, it is used as a
socket.io adapter, helping when scaling up with multiple instances of the backend. This way we can broadcast a message
to multiple clients even if they are connected to a different server. You can read more about
that <a href=https://socket.io/docs/v4/redis-adapter/>here</a>.</p><h1 id=frontend>Frontend<a hidden class=anchor aria-hidden=true href=#frontend>#</a></h1><p>Last but not least, the Frontend is built on Vue.js, and is a single page application that makes the dashboard of
Ichnaea. Vue is a lovely framework that is extensible with things like routing and state management. I won&rsquo;t go into any
details about the framework - feel free to browse the <a href=https://v3.vuejs.org/>docs</a>.</p><p>I tried to make the dashboard as realistic as possible. It has the following features:</p><ul><li>View the latest README from Github right in the app.</li><li>Make changes to the user and athlete profile.</li><li>Adopt or drop athletes.</li><li>View, search, or inspect athletes and their details.</li><li>View athlete data in a table or model in real-time.</li></ul><p>Not something overly impressive, but some basic functionality that would form the building blocks of a real-world app.</p><p>The main point of the dashboard is the model animation. I fixed a <a href=http://mixamo.com>Mixamo</a> model to a Three.js scene,
and with the help of <a href=https://en.wikipedia.org/wiki/Quaternion>quaternions</a>, the model animation is a breeze. I used
the build in function from Three.js for the conversion from Euler, setFromEuler(). Taking a look inside setFromEuler(),
we can see that the conversion is simple enough.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff7b72>const</span> cos <span style=color:#ff7b72;font-weight:700>=</span> Math.cos;
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> sin <span style=color:#ff7b72;font-weight:700>=</span> Math.sin;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> c1 <span style=color:#ff7b72;font-weight:700>=</span> cos(x <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> c2 <span style=color:#ff7b72;font-weight:700>=</span> cos(y <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> c3 <span style=color:#ff7b72;font-weight:700>=</span> cos(z <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> s1 <span style=color:#ff7b72;font-weight:700>=</span> sin(x <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> s2 <span style=color:#ff7b72;font-weight:700>=</span> sin(y <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#ff7b72>const</span> s3 <span style=color:#ff7b72;font-weight:700>=</span> sin(z <span style=color:#ff7b72;font-weight:700>/</span> <span style=color:#a5d6ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>this</span>._x <span style=color:#ff7b72;font-weight:700>=</span> s1 <span style=color:#ff7b72;font-weight:700>*</span> c2 <span style=color:#ff7b72;font-weight:700>*</span> c3 <span style=color:#ff7b72;font-weight:700>+</span> c1 <span style=color:#ff7b72;font-weight:700>*</span> s2 <span style=color:#ff7b72;font-weight:700>*</span> s3;
</span></span><span style=display:flex><span><span style=color:#ff7b72>this</span>._y <span style=color:#ff7b72;font-weight:700>=</span> c1 <span style=color:#ff7b72;font-weight:700>*</span> s2 <span style=color:#ff7b72;font-weight:700>*</span> c3 <span style=color:#ff7b72;font-weight:700>-</span> s1 <span style=color:#ff7b72;font-weight:700>*</span> c2 <span style=color:#ff7b72;font-weight:700>*</span> s3;
</span></span><span style=display:flex><span><span style=color:#ff7b72>this</span>._z <span style=color:#ff7b72;font-weight:700>=</span> c1 <span style=color:#ff7b72;font-weight:700>*</span> c2 <span style=color:#ff7b72;font-weight:700>*</span> s3 <span style=color:#ff7b72;font-weight:700>+</span> s1 <span style=color:#ff7b72;font-weight:700>*</span> s2 <span style=color:#ff7b72;font-weight:700>*</span> c3;
</span></span><span style=display:flex><span><span style=color:#ff7b72>this</span>._w <span style=color:#ff7b72;font-weight:700>=</span> c1 <span style=color:#ff7b72;font-weight:700>*</span> c2 <span style=color:#ff7b72;font-weight:700>*</span> c3 <span style=color:#ff7b72;font-weight:700>-</span> s1 <span style=color:#ff7b72;font-weight:700>*</span> s2 <span style=color:#ff7b72;font-weight:700>*</span> s3;
</span></span></code></pre></div><p>I also keep a reference of body parts, and set its position as so.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff7b72>this</span>.head <span style=color:#ff7b72;font-weight:700>=</span> object.getObjectByName(<span style=color:#a5d6ff>&#39;mixamorig1Head&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>this</span>.head.quaternion.setFromEuler(<span style=color:#ff7b72>new</span> Euler(<span style=color:#ff7b72>this</span>.roll, <span style=color:#ff7b72>this</span>.yaw, <span style=color:#ff7b72>this</span>.pitch));
</span></span></code></pre></div><h1 id=demo>Demo<a hidden class=anchor aria-hidden=true href=#demo>#</a></h1><p>Placing the micro-controller on top of the head and making three discreet movements from neutral to left, back, and
upwards right, maps with precision the physical movement and accurately depicts it on the model while testing all three
axes, roll-pitch-yaw.</p><p><img loading=lazy src=/blog/ichnaea/testing-01.png#center alt=Untitled></p><p>Let&rsquo;s try the same but for another body part, this time the left arm. Starting from a relaxed hanging position we pull
the arm upwards making a slow circular motion and then returning to the starting point. This time due to us deliberately
making a slow movement, we can now see the drift introduced from the gyroscope in the yaw angle. That skews with all the
readings and thus placing the hand in a wrong final position.</p><p><img loading=lazy src=/blog/ichnaea/testing-02.png#center alt=Untitled></p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>This was an overview of Ichnaea, what I thought were the most interesting points, and by no means the full picture. What
needs to be improved? Abstracting the sensor positioning logic to a UI where the user can drag and drop each sensor to
the respective body and not hard-coding it. Making the client device smaller and self-sufficient with a battery and
extensive connectivity options. Lastly, some ML with smart alerts and corrections would provide smart insights.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://haris.razis.com/tags/web/>Web</a></li><li><a href=https://haris.razis.com/tags/frontend/>Frontend</a></li><li><a href=https://haris.razis.com/tags/backend/>Backend</a></li><li><a href=https://haris.razis.com/tags/networking/>Networking</a></li><li><a href=https://haris.razis.com/tags/system/>System</a></li></ul><nav class=paginav><a class=prev href=https://haris.razis.com/posts/alfacycling/><span class=title>« Prev</span><br><span>A naive approach to blogging</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://haris.razis.com/>xrazis · Haris Razis</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>