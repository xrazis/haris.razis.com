<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Frontend on xrazis · Haris Razis</title>
    <link>https://haris.razis.com/tags/frontend/</link>
    <description>Recent content in Frontend on xrazis · Haris Razis</description>
    <image>
      <title>xrazis · Haris Razis</title>
      <url>https://haris.razis.com/</url>
      <link>https://haris.razis.com/</link>
    </image>
    <generator>Hugo -- 0.139.0</generator>
    <language>en</language>
    <lastBuildDate>Thu, 18 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://haris.razis.com/tags/frontend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to create a snowfall effect in the browser</title>
      <link>https://haris.razis.com/posts/snowfall-canvas-library/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://haris.razis.com/posts/snowfall-canvas-library/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The Canvas API is used to draw graphics with Javascript. It can be utilized to make browser games, animations, visualize
data, and much more. We will create a really basic Canvas library that receives input from a configuration file and
draws the falling items animation.&lt;/p&gt;
&lt;h1 id=&#34;particle-class&#34;&gt;Particle Class&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;Particle&lt;/code&gt; class represents a single falling object. It is initialized with the same config object as the &lt;code&gt;Effect&lt;/code&gt;
class, as it needs many of the same parameters for correctly placing a particle inside the viewport. The constructor
is where the majority of the logic is placed. After randomly picking the position in the canvas, we set the size and
speed with &lt;code&gt;Math.random()&lt;/code&gt; so we get an effect of depth and different weight for each object.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to build a React Portlet on Liferay 7.2 with widgets</title>
      <link>https://haris.razis.com/posts/liferay-widgets-react/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://haris.razis.com/posts/liferay-widgets-react/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;At my day job we decided to rewrite a Liferay portlet to React, it displays draws and results data from different
numeric games (the client is a betting company slowly porting many of their games online). This particular portlet has
been a pain in the ass to maintain, port new CRs, and was horrible performance wise, and that is because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The code was inherited from another company and was written a long time ago with questionable structure/logic. There
was never enough time to do a proper cleanup or rewrite.&lt;/li&gt;
&lt;li&gt;It tries to handle many different numeric games and in turn the code ends up being incomprehensible and bug prone.&lt;/li&gt;
&lt;li&gt;It has many expensive DOM operations.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;react-application&#34;&gt;React Application&lt;/h1&gt;
&lt;p&gt;Developing the React application standalone and outside of Liferay is a huge boost of productivity as you can take
advantage of features like live reloading and your IDE&amp;rsquo;s debugger. This particular project is based on a monolithic
architecture with no direct communication to the server from the client (ex websockets). It is tightly coupled with
third party vendors and much of the information displayed comes from APIs that other teams use as well (ex mobile
vendor). Some of the API calls happen at the backend at a predefined interval, this way the endpoint does not get
bottled down from requests. That information is exposed to a window variable so that specific context can be
accessible from different parts of the application.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Handling emails for statically generated sites</title>
      <link>https://haris.razis.com/posts/form-endpoint/</link>
      <pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://haris.razis.com/posts/form-endpoint/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Statically generated sites are fast and flexible but don&amp;rsquo;t have the ability to send &lt;em&gt;&lt;strong&gt;contact us&lt;/strong&gt;&lt;/em&gt; emails due to the
lack of a backend. A simple solution would be using a service like Airform, Mailgun, or Formspree, but where&amp;rsquo;s the fun
in that? Instead, we can build a simple Express.js API that will handle POST requests from a form and will in turn
forward that email to a mailbox.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A naive approach to blogging</title>
      <link>https://haris.razis.com/posts/alfacycling/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://haris.razis.com/posts/alfacycling/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Building a blog from the ground up can be quite interesting. It won’t and can’t be a match to a feature-rich blogging
engine, without any substantial effort at least, but it will help you understand topics like REST, CRUD, and many more.
A while ago I created &lt;a href=&#34;https://github.com/xrazis/alfacycling.com&#34;&gt;alfacycling.com&lt;/a&gt;, a primitive blog to get my hands
dirty with new technologies.&lt;/p&gt;
&lt;h1 id=&#34;architecture&#34;&gt;Architecture&lt;/h1&gt;
&lt;p&gt;The idea behind this project was pretty simple, have a landing page with some info about the team and two sub-routes
with all the blogging and user functions. There is no user support besides a moderator, with some basic capabilities
like creating, editing, or deleting a blog post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scalable IoT solution for real-time body position tracking</title>
      <link>https://haris.razis.com/posts/ichnaea/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://haris.razis.com/posts/ichnaea/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A while ago I submitted my thesis with its subject being the study of the architecture of BAN and PAN, and their
applications, with the aim of optimizing athletes performance, by enhancing personalized training practices. I was also
tasked with creating an e-sport application that would collect and analyze data on the athlete’s body position in
real-time. I named the e-sport application Icnhaea, and I will be referring to it as so for the rest of this post.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
